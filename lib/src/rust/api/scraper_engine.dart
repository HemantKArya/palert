// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'browser_service_manager.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `try_get_page_source`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `drop`, `fmt`, `fmt`
// These functions have error during generation (see debug logs or enable `stop_on_error: true` for more details): `shutdown`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BrowserEngine>>
abstract class BrowserEngine implements RustOpaqueInterface {
  /// Checks the health of the browser service
  Future<BrowserEngineStatus> checkServiceStatus();

  /// Closes the currently active tab/window.
  Future<void> closeCurrentTab();

  /// Gets the current port being used
  Future<int> getCurrentPort();

  /// Navigates to a URL and returns the page source with automatic retry
  Future<String> getPageSource({required String url});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new BrowserEngine with service management and fallback
  static Future<BrowserEngine> newInstance(
          {required int port,
          required String browserPath,
          required String driverPath}) =>
      RustLib.instance.api.crateApiScraperEngineBrowserEngineNew(
          port: port, browserPath: browserPath, driverPath: driverPath);

  /// Creates a new BrowserEngine with automatic port management
  static Future<(BrowserEngine, ServiceStatus)> newWithFallback(
          {required int initialPort,
          required String browserPath,
          required String driverPath}) =>
      RustLib.instance.api.crateApiScraperEngineBrowserEngineNewWithFallback(
          initialPort: initialPort,
          browserPath: browserPath,
          driverPath: driverPath);

  /// Restarts the browser service with fallback mechanisms
  Future<ServiceStatus> restartWithFallback();
}

class BrowserEngineStatus {
  final bool isRunning;
  final int currentPort;
  final String message;
  final bool requiresRestart;

  const BrowserEngineStatus({
    required this.isRunning,
    required this.currentPort,
    required this.message,
    required this.requiresRestart,
  });

  @override
  int get hashCode =>
      isRunning.hashCode ^
      currentPort.hashCode ^
      message.hashCode ^
      requiresRestart.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BrowserEngineStatus &&
          runtimeType == other.runtimeType &&
          isRunning == other.isRunning &&
          currentPort == other.currentPort &&
          message == other.message &&
          requiresRestart == other.requiresRestart;
}
