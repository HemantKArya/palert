// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'browser_service_manager.dart';
import 'models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PriceEngine>>
abstract class PriceEngine implements RustOpaqueInterface {
  /// Checks the health status of the browser service
  Future<PriceEngineStatus> checkServiceStatus();

  /// Creates a backup of the database in JSON format
  Future<void> createBackup({required String backupPath});

  /// Fetches product details with automatic retry and fallback mechanisms
  Future<ProductRecord> fetchAndUpdateProduct({required String url});

  Future<List<ProductRecord>> getAllProductsInDb();

  /// Gets the current port being used by the browser service
  Future<int> getCurrentPort();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<PriceEngine> newInstance(
          {required int port,
          required String browserPath,
          required String dbPath,
          required String driverPath}) =>
      RustLib.instance.api.crateApiPriceEnginePriceEngineNew(
          port: port,
          browserPath: browserPath,
          dbPath: dbPath,
          driverPath: driverPath);

  /// Removes a product from the database by its ID.
  Future<void> removeProductById({required String productId});

  /// Restarts the browser service if needed
  Future<ServiceStatus> restartBrowserService();

  /// Restores database from a JSON backup file
  Future<void> restoreFromBackup(
      {required String backupPath, required bool replaceExisting});

  /// Shuts down the browser engine gracefully.
  Future<void> shutdown();
}

class PriceEngineStatus {
  final bool isHealthy;
  final int currentPort;
  final String message;
  final String lastCheck;

  const PriceEngineStatus({
    required this.isHealthy,
    required this.currentPort,
    required this.message,
    required this.lastCheck,
  });

  @override
  int get hashCode =>
      isHealthy.hashCode ^
      currentPort.hashCode ^
      message.hashCode ^
      lastCheck.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PriceEngineStatus &&
          runtimeType == other.runtimeType &&
          isHealthy == other.isHealthy &&
          currentPort == other.currentPort &&
          message == other.message &&
          lastCheck == other.lastCheck;
}
